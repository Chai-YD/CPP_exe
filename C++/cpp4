1.对引用类型执行sizeof运算得到被引用对象所占空间的大小；对数组执行sizeof得到整个数组所占空间的大小。sizeof运算不会把数组转换成指针处理；对string对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素占用多少空间。
注意：在32位平台下：vector对象占16
2.sizeof多维数组
3.union数据类型所占的空间
    都知道union的大小取决于它所有的成员中，占用空间最大的一个 成员的大小。在计算union的大小时，还应该关注union中的最大对其数。
4.内存对其的原则？
    内存对其的好处是提高CPU访问内存的效率。
    总的来说：结构体的大小 就是成员的大小，与最大对其数的最小公倍数进行求最大值的运算。
5.因为static成员是分配在全局区为类的所属共享，sizeof时不应该计入stati成员。
6.C++的多态性？
    多态可以简单的概括为“一个接口，多种方法”。
    分为编译时多态和运行时多态。
    编译时多态：通过重载函数实现。重载允许有多个同名的函数。而这些函数的参数列表不同。编译器会根据参数类型来选定相对应的函数；
    运行时多态性：通过虚函数实现。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法成为覆盖，或者重写。
7.动态绑定是如何实现的？
    当基类的指针或引用指向一个派生类的对象时，会发生动态绑定。直到运行时才能够确定调用的是哪个版本的虚函数，判断的依据是引用和指针所绑定的对象的真实类型。
8.类型转换有哪些？
    static_cast：任何具有明确定义的类型转换，只要不包含const，都可以使用。
    如：static_case<double>(int);//将一个int类型数据转换为double
    const_cast：用于去掉指针或引用的const属性。
    如：const int i = 10;
        int *k = const_cast<int*>(&i);
        *k = 5;//去掉指针的const属性后，可以重新对其赋值。
    reinterpret_cast：一个类型的指针转换为其他类型的指针。
    允许将任何指针类型转换为其他指针类型；听起来很强大，但是也很不靠谱。它主要用于将一种数据类型从一种类型转换成另一种类型。它可以将指针转换为整数，也可以将整数转换为指针，在实际开发中，先把一个指针转换成一个整数，再把该整数转换为指针，还可以得到原来的指针值。
    dynamic_cast：主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
    在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。
    在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast安全。
9.内联函数的优点以及和宏定义的区别？
    宏定义是预处理阶段进行简单的替换，而内联函数是在编译期进行替换；
    编译器对内联函数有类型的检测，而宏定义则没有；
    内联函数在运行时可调试，而宏不可以:
    在类中声明同时定义的成员函数，自动转化为内联函数；
    宏有二义性，而内联函数没有；
    内联函数可以访问类的成员变量，而宏定义不可以。
10.const和#define的区别？
    区别：编译器处理方式不同（宏在预处理阶段替换，const在编译阶段替换）
    类型和安全检测不同（宏没有类型，不做安全检测，从上图、有类型，在编译阶段进行安全检查）
11.C语言和C++有什么区别？
    C语言是结构化的编程语言，它是面向过程的，而C++是面向对象的。
    疯转：将数据和函数集合在一个单元中（即类）。在封装的类通常成为抽象数据类型。封装的意义在于保护和防止代码被我们无意间修改。
    继承：继承主要实现重用代码，节省开发时间。它可以使用现有类的所有功能，并在无需要编写原来的类的情况下对这些功能进行扩展。
    多态：同一操作属于不同的对象，可以有不同分解释，产生不同的结果。在运行时，可以通过指向派生类的基类指针，来调用实现派生类中的方法。有编译时多态和运行时多态。
12.容器适配器有哪些？他们默认的底层适配器是什么？
    stack：默认是deque，vector和list也可以作为底层适配容器。
    queue：默认是deque，list也作为底层适配容器。因为queue同时 支持front和back操作，所以不能用vector作为底层的适配容器。
    priority_queue:默认是vector《也可以 是deque。因为priority_queue要求能对元素随机访问以便能够排序，所以不能用list。
13.几种容器迭代器删除元素时会发生什么？
    对于vector和string，指向其删除点之后位置的迭代器，引用和 指针都会失效。
    对于deque，删除除首尾位置之外的任何元素都会使所有迭代器，引用和指针失效。
    对于list，指向容器其他位置的迭代器，引用和指针都不会失效。
    对于插入操作，影响和删除操作一样。
14.delete和delete[]的区别？
    delete只调用一次析构函数；delete[]会调用每一个成员的析构函数。
15.将“引用”作为函数的行参有哪些特点？
    传递引用给函数 与传递指针的效果是一样的。
    使用引用传递函数的参数，在内存中并没有产生实参的副本。
    使用指针，在被掉函数中同样要给行参分配内存单元。
16.类成员函数的重载、覆盖和隐藏区别？
    a、成员函数被重载的特征：
        相同的范围
        函数名相同
        参数不同
        virtual关键字可有可无
    b、覆盖是指派生类函数覆盖基类函数，特征：
        不同的范围
        函数名相同
        参数相同
        基类函数必须有virtual关键字
    c、隐藏是指派生类的函数屏蔽了其同名的基类函数，特征：
        如果派生类的函数与基类函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏；
        如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，基类的函数将被隐藏。





































