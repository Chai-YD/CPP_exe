1.大端和小端？与寻常习惯的区别？
    大端：高地址存储低位字节
    小端：低地址存储低位字节
    大端的存储与寻常 习惯相一致，而小端的存储方式为按照字节倒排
2.#include<>与#include""的区别？
    优先搜索路径不同
    前者优先搜索标准文件目录
    后者优先搜索自定义文件目录
3.C++将基类的析构函数定位为虚函数的目的？
    若将基类的析构函数定义成虚函数，当删除开一个指向派生类的基类指针时，首先会调用派生类的析构函数，然后调用积累的析构函数；否则只会调用基类的析构函数（这样有可能会造成内存泄漏）
4.mutable定义数据成员的意义？
    mutable定义的数据成员，可以在const中进行修改
5.怎样定义纯虚函数？纯虚函数与抽象类的关系？抽象类的特点？
    将虚函数赋值为0即可得到一个纯虚函数；包含纯虚函数的类成为抽象类。抽象类有以下特点：不能实例化；不能作为函数的参数及函数返回类型（由于抽象类不能实例化）；可以定义抽象类指针。抽象类一般作为基类使用。对于一个抽象类，如果其派生类没有重新定义基类的虚函数，则派生类也是抽象类，只有派生类重新定义了基类的虚函数，派生类才不再是抽象类，才是一个可以建立对象的具体类。
6.malloc与new的区别？
    malloc是函数，new是操作符；malloc申请内存时，需要指定申请的空间大小，且返回的类型为void*，需要将其强制类型转换为所需类型的指针；new申请内存时，会根据申请的类型自动计算申请空间的大小，且可直接返回指定类型的指针；mallo释放内存时，使用free函数，new删除对象时，用的是delete操作符；malloc/free申请释放内存时，不需要调用析构函数，而new/delete申请释放内存时需要调用析构函数。
7.二维数组作为参数传递的注意事项？
    需要指明数组的第二维，第一维不是 必须要显示指明。
8.建立动态二维数组的两种方法？在删除用new建立的二维数组时注意事项？
    法一|申请空间：
{
    int **a = new int *[row];比一维的等号两边多了两个*
    for（int i = 0;i<row;i++）
        a[i] = new int[cloumn];
}
    该方法定义的动态二维数组的释放需要先释放指针数组的每个元素指向的数组，然后再释放该指针数组：
{
    for(int i = 0;i<row;i++){
        delete a[i];
        a[i] = NULL;
    }
    delete [row]a;
    a = NULL;
}
    法二：
{
    vector<vector<int>> vec(row,vector<int>(cloumn));
}
9.sizeof运算法在编译阶段处理的特性？
    sizeof操作符在其作用范围内，内容不会被编译，而是简单替换成其类型。
10.sizeof(字符串序列)和sizeof(字符串数组)的区别？
    sizeof(字符串序列) = 字符串长度+1
    sizeof(字符串数组) = 字符串长度(用{}来表示)
11.sizeof（动态数组）？
    动态数组实质上是一个指针，其占用空间为4/8（32位/64位系统）。
12.用strlen得到字符串的长度？
    对于字符串序列，到最后一个'\0'为止（'\0'自动添加且不计算在内）；对于字符串数组，必须要显示指定'\0'。对于string型字符串，不能直接使用strlen，而需要使用strlen（s.c_str()）计算。
13.sizeof(联合)需要注意的占用空间最大的成员及对其方式问题？
    联合和结构的区别：结构中各成员有各自的内存空间，结构变量所占内存是各成员所占内存空间之和；联合中，各成员共享一段内存空间，一个联合变量所占用内存空间等于 各成员中所占内存空间最大的变量所占用内存空间（需要考虑内存对其问题），此时共享意味着每次只能赋一个值，赋入新值则冲去旧值。
14.sizeof（class）需要注意情况？
    sizeof只是计算数据成员的大小，不计算static数据成员的大小；继承时需要考虑基类数据成员问题，考虑虚函数问题，无论有多少各虚函数，计算空间时虚函数表只计算一次。
    注意：对于同一个类中的不同虚函数，只是需要考虑一次，但是对于不同类的虚函数，派生类需要都考虑。
15.rand()函数的用法？srand函数的用法？
{
    rand();
    srand((unsigned int)time(NULL));
} 
16.++a和a++的问题？
    ++a得到左值，a++得到右值。
17.静态分配与动态分配的区别？
    静态分配是指在编译期间就能确定内存的大小，由编译器分配内存。动态分配是指在程序允许期间，由程序员申请的内存空间。堆和栈都可以动态分配，但静态分配只能是栈。
18.构造函数的列表初始化 的初始化顺序？哪三种情况是必须的？
    const数据成员；引用数据成员；没有默认构造函数的成员对象
    对于static成员：若是static const成员，可以在类外初始化，也可以在类内进行初始化；若是static成员，只能在类内进行初始化。
19.C++的转义序列？\abc与\xabc分别表示什么？
    \abc表示8进行转移序列；\xabc表示16进制的转义序列。
20.当编译器处理一个const时会将其转化成一个立即数。
21.为什么不能重新定义一个继承而来的默认参数？
    因为从基类继承来的缺省参数值都是静态绑定的，而virtual函数-你唯一应该覆盖的东西，却是动态绑定。
22.为什么不能重新定义一个继承而来的非虚函数？
    因为非虚函数是静态绑定的，如果重新定义继承而来的非虚函数，则指向派生类的基类指针调用该虚函数时，将有可能产生异常。
23.深拷贝与浅拷贝的区别？
    深拷贝是指原对象与拷贝对象相互独立，其中任意一个对象的改变，不会对另一个对象造成影响；浅拷贝是指原对象与拷贝对象是一个实体，就仅仅是引用的变量不同（名称不同），对其中任意一个对象的改动都会影响另一个对象。
24.类的静态成员是所有类的实例共有的，存储在全局（静态）区，只是一份，不管继承、实例化还是拷贝都是一份。因此类的静态成员不允许深拷贝。
25.如何只让类对象只在堆（栈）上分配对象？
    1：只在堆上分配对象
    动态建立对象，是使用new运算符将对象建立在堆空间中。分配空间，调用构造函数进行初始化。
    2.只在栈上分配对象
    只要禁用new操作符就可以实现类对象只能 建立在栈上。
    注意：将构造函数设为私有，不能在堆上分配对象；将析构函数设为私有，不能在栈上分配对象（在栈上分配空间时，编译器先进行对析构函数、非静态函数进行检查）。
26.char扩张成int的两种扩展方式？
    判断char为unsigned还是signed，前者进行0扩张，后者进行符号位扩张。
27.面向过程static全局变量与全局对象的区别？
    全局变量默认是有外部链接性的，作用域在整个工程，在一个文件内定义的全局变量，在另一个文件中，通过exter全局变量名的声明，就可以使用全局变量；
    静态全局变量是显示用static修饰的全局变量，作用域是声明此变量所在文件，其他的文件即使用exter声明也不能使用。
28.面向过程静态局部变量的特点？
    在全局数据区分配内存；在程序执行到该对象的声明处被首次初始化，且以后 不再初始化；一般在声明处初始化，如果没用显示初始化，会被程序自动初始化为0；它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。29.面向对象静态数据成员的特点？
    静态数据成员被当作是类的成员。只分配一次内存，供所有对象使用；静态数据 成员存储在全局数据区，静态数据成员定义时要分配空间，所以不能在类声明中定义；不属于特定的类对象。
    区别：
    静态成员初始化与一般数据成员初始化不同；静态数据成员主要用于各个  对象都有相同的某项属性的时候。
    优势：（相对于全局变量）
    不存在与程序中其他全局名字冲突的可能性；
可以实现信息隐蔽。
30.面向对象静态成员函数的特点？
    只能访问静态成员。
31.静态成员与非静态 成员之间的可访问性？
    静态成员之间可以相互访问；非静态成员可以访问静态成员及非静态成员，而静态成员不能访问非静态成员。
34.memcpy与strcpy之间的区别？
    复制的内容；复制的方法；用途。
35.不能声明为虚函数的几种情况？
    普通函数（非类成员函数）（不能被覆盖）
    有元函数（C++不支持有元函数继承）
    内联函数（编译期间展开，虚函数是运行期间绑定）
    构造函数（没有对象不能使用虚函数，先有构造函数后有虚函数，虚函数是对对象的动作（构造函数不能继承 ））
    静态成员函数（只有一份，大家共享）
36.虚函数的定义及功能？
    功能：
    在某基类中声明为virtual并在一个或 多个派生类中被重新定义的非stati成员函数。
    功能：
    实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。
37.malloc、alloc、calloc、realloc的区别？
    alloc：唯一在栈上申请内存的，无需释放；
    malloc：在堆上申请内存，最常用；
    calloc：malloc+初始化为0；
    realloc：将原本申请的内容区域扩容，参数size大小即为扩容后大小，因此此函数要求size必须大于ptr内存的大小。
38.什么是多态？
    多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，在运行时，可以通过指定派生类的基类的指针或引用，来调用实现派生类中的方法。
39.在32位系统中和64位系系统中long分别占用多少字节？
    32位：4字节；64位：8字节
40.#define与typedef的区别？
    #define是预处理指令，在编译预处理时进行简单的替换；typedef是在编译时处理的。
41.堆和栈的区别？
    栈，有编译器管理，无需我们手工控制，堆，申请释放由程序员控制；栈的生长方向是向下的，是像着内存地址减小的方向增长，堆的生长方向是向上的，是向着内存地址增加的方向增长；
42.指针和引用的相同点与区别？
    相同点：都是地址的别名
    地址的概念：指针指向一块内存，她的内容是所指向内存的地址；引用是某块内存的别名。
    区别：
    指针是一个实体，而引用仅是个别名；
    引用使用时无需解引用(*)，指针需要解引用；
    引用只能在定义时被初始化一次，之后不可变；指针可改变；
    引用不能为空，指针可以为空；
    sizeof指针与引用；
    从内存分配来看：程序为指针变量分配内存区域，而引用不需要分配内存区域。
43.初始化与赋值的区别？
    初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值删除掉，而以一个新值替代。
44.声明与定义的 区别？
    为了支持分离式编译，C++将声明和定义区分开来。声明使得名字为程序所知道，一个文件如果想使用别处定义的名字则需要包含对那个名字的声明。定义负责创建与名字关联的实体。
    简单来说，声明规定的变量的类型和名字，在这一点上与定义相同。但定义还申请了内存空间妈妈也可能会为变量赋值一个 初始值。


















